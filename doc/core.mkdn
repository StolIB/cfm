Clash Forth Machine
===================

The CFM core is a 16-bit dual-stack CPU patterned after James Bowman's J1 core.

## Architectural highlights

- Memory, stacks, and PC are 16 bits wide.
- There are two stacks, data and return, for supporting Forth code.
- Calls are single-cycle, returns can often be folded into a previous
  instruction.

## Compared to the J1

Compared to the J1, the main deviation is that the CFM targets Lattice ICE40
FPGAs. The ICE40 series uses 1R1W RAM, i.e. simple dual-ported RAM that can
issue a single read and a single write independently per cycle. By contrast,
the J1 targeted Xilinx's block RAMs, which are 1R1RW -- they can issue two
reads. The J1 used this to ensure that a code fetch could always overlap with a
memory operation; on ICE40 we have no such luxury.

As a result,

- Bit 4 in the instruction has been repurposed to mean "begin load."
- Loads now take two cycles.

## Instruction encoding and timing

CFM instructions are 16 bits wide and loaded from aligned addresses in memory.

There are four instruction types. All run in a single cycle unless noted
otherwise.

### Push Literal

    15  14                           0
    +--+------------------------------+
    |1 |         value                |
    +--+------------------------------+

Effect: `( -- value)`

`value` is zero-extended and pushed to the data stack.

To get a literal with bit 15 set, use this instruction and complement the
result.

### Jump

    15   13 12                       0
    +------+--------------------------+
    |0 0 0 |     target               |
    +------+--------------------------+

Effect: `( -- )`

`target` is zero-extended and loaded into the PC.

### Jump if Zero

    15   13 12                       0
    +------+--------------------------+
    |0 0 1 |     target               |
    +------+--------------------------+

Effect: `( f -- )`

Pops a flag off the data stack. If it is zero, `target` is zero-extended and
loaded into the PC. Otherwise, execution continues linearly.

### Call

    15   13 12                       0
    +------+--------------------------+
    |0 1 0 |     target               |
    +------+--------------------------+

Effect: `( -- )` `R: ( -- raddr )`

Pushes the address of the next instruction onto the return stack.

`target` is zero-extended and loaded into the PC.

### ALU

    15   13                          0
    +------+--+--------+--+--+--+--+----+----+
    |0 1 1 |RP| Tmux   |TN|TR|NM|MT|Radj|Dadj|
    +------+--+--------+--+--+--+--+----+----+

The everything-else instruction. This instruction carries unencoded control
information for the processor datapath.

The single bit fields function as follows when *set*:

`RP`: the top cell of the return stack is loaded into PC.

`TN`: the top cell of the data stack is copied into the second cell.

`TR`: the top cell of the data stack is copied into the top cell of the return
stack.

`NM`: the second cell of the data stack is stored to memory at the address held
in the top cell.

`MT`: the memory cell addressed by T is loaded into T. **This takes an
additional cycle.**

The `Tmux` field controls a multiplexer that chooses the next value for T.
    0 -> t
    1 -> n
    2 -> t + n
    3 -> t .&. n
    4 -> t .|. n
    5 -> t `xor` n
    6 -> complement t
    7 -> signExtend $ pack $ n == t
    8 -> signExtend $ pack $ unpack @(Signed 16) n < unpack t
    9 -> n `shiftR` fromIntegral t
    10 -> t - 1
    11 -> r
    -- 12 currently reserved
    13 -> n `shiftL` fromIntegral t
    14 -> zeroExtend depth
    15 -> signExtend $ pack $ n < t

Notes on those options:

- Comparison results generate a full-word bitmask, in keeping with Forth
  tradition, rather than setting only bit 0 like MIPS.
- One option (12) was read-from-memory on J1, which isn't so simple in CFM and
  is thus reserved.
- `depth` (option 14) yields the current data stack pointer when the instruction
  began executing.

The `Radj` and `Dadj` fields hold twos-complement integers that are added to the
return and data stack pointers, respectively. The addition is performed *after*
the respective stacks are read, but *before* they are written. That is, an
ALU instruction with the fields

    TN = 1
    Tmux = 1
    Dadj = -1

has the effects

    T <= DSTACK[dptr]
    DSTACK[dptr - 1] <= T

or as a Forth stack comment: `( x n t -- t n )`.
